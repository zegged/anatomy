<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>POC â€“ Three.js + GLB</title>
    <style>
      html,body{margin:0;height:100%}
      canvas{display:block;width:100%;height:100%}
      #ui-panel {
        position: absolute;
        top: 10px;
        right: 10px;
        background: rgba(32, 33, 36, 0.9);
        color: white;
        padding: 15px;
        border-radius: 8px;
        max-width: 250px;
        font-family: Arial, sans-serif;
        font-size: 14px;
      }
      #ui-panel h3 { margin: 0 0 10px 0; font-size: 16px; }
      #nerve-list { margin-bottom: 10px; }
      .nerve-item { display: flex; align-items: center; margin-bottom: 5px; }
      .nerve-item input { margin-right: 8px; }
      .nerve-item label { cursor: pointer; }
      #controls { display: flex; gap: 5px; }
      #controls button {
        flex: 1;
        padding: 5px 8px;
        background: #4285f4;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 12px;
      }
      #controls button:hover { background: #3367d6; }
    </style>
    <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.157.0/build/three.module.js",
        "three/examples/jsm/": "https://unpkg.com/three@0.157.0/examples/jsm/"
      }
    }
    </script>
  </head>
  <body>
    <div id="ui-panel">
      <h3>Cranial Nerves</h3>
      <div id="nerve-list"></div>
      <div id="controls">
        <button id="show-all">Show All</button>
        <button id="hide-all">Hide All</button>
        <button id="solo">Solo</button>
        <button id="frame">Frame</button>
      </div>
    </div>
    <canvas id="c"></canvas>
    <script type="module">
      import * as THREE from 'three';
      import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
      import { OBJLoader } from 'three/examples/jsm/loaders/OBJLoader.js';
      import { MTLLoader } from 'three/examples/jsm/loaders/MTLLoader.js';
      import { STLLoader } from 'three/examples/jsm/loaders/STLLoader.js';
      import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
      import { DRACOLoader } from 'three/examples/jsm/loaders/DRACOLoader.js';

      // Configure Draco loader for compressed GLBs
      const dracoLoader = new DRACOLoader();
      dracoLoader.setDecoderPath('https://unpkg.com/three@0.157.0/examples/js/libs/draco/');

      const canvas = document.querySelector('#c');
      const renderer = new THREE.WebGLRenderer({ antialias: true, canvas });
      renderer.setPixelRatio(devicePixelRatio);
      renderer.setSize(innerWidth, innerHeight);
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x202124);
      const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 100);
      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;

      scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 1.0));
      const dir = new THREE.DirectionalLight(0xffffff, 1.0); dir.position.set(5,10,7.5); scene.add(dir);

      const MODEL_ROOT = './models/anatomytool/';
      const GLB = MODEL_ROOT + 'model.glb';
      const GLTF = MODEL_ROOT + 'model.gltf';
      const OBJ = MODEL_ROOT + 'model.obj';
      const MTL = MODEL_ROOT + 'model.mtl';
      const STL = MODEL_ROOT + 'model.stl';

      async function exists(url){ const r = await fetch(url,{method:'HEAD'}); return r.ok; }

      async function loadModel(scene) {
        // Prefer GLB/GLTF for textures and performance
        if (await exists(GLB)) {
          const loader = new GLTFLoader();
          loader.setDRACOLoader(dracoLoader);
          const gltf = await loader.loadAsync(GLB);
          scene.add(gltf.scene);
          return gltf.scene;
        }
        if (await exists(GLTF)) {
          const loader = new GLTFLoader();
          loader.setDRACOLoader(dracoLoader);
          const gltf = await loader.loadAsync(GLTF);
          scene.add(gltf.scene);
          return gltf.scene;
        }
        // Fall back to OBJ+MTL for textures
        if (await exists(MTL) && await exists(OBJ)) {
          const mtl = await new MTLLoader().loadAsync(MTL);
          mtl.preload();
          const objLoader = new OBJLoader();
          objLoader.setMaterials(mtl);
          const obj = await objLoader.loadAsync(OBJ);
          scene.add(obj);
          return obj;
        }
        // Fall back to OBJ only
        if (await exists(OBJ)) {
          const obj = await new OBJLoader().loadAsync(OBJ);
          scene.add(obj);
          return obj;
        }
        // Final fallback to STL
        if (await exists(STL)) {
          const geom = await new STLLoader().loadAsync(STL);
          const mat = new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0.1, roughness: 0.8 });
          const mesh = new THREE.Mesh(geom, mat);
          scene.add(mesh);
          return mesh;
        }
        throw new Error('No supported model found under ' + MODEL_ROOT);
      }

      // Load cranial nerve models from manifest
      const nerveGroup = new THREE.Group();
      scene.add(nerveGroup);
      const idToNerve = new Map();
      let lastToggledNerve = null;

      // UI elements
      const nerveList = document.getElementById('nerve-list');
      const showAllBtn = document.getElementById('show-all');
      const hideAllBtn = document.getElementById('hide-all');
      const soloBtn = document.getElementById('solo');
      const frameBtn = document.getElementById('frame');

      // UI event handlers
      showAllBtn.addEventListener('click', showAllNerves);
      hideAllBtn.addEventListener('click', hideAllNerves);
      soloBtn.addEventListener('click', () => soloNerve(lastToggledNerve));
      frameBtn.addEventListener('click', () => frameNerve(lastToggledNerve));

      async function loadNerveModels(scene) {
        const manifestUrl = './models/nerves/manifest.json';
        const response = await fetch(manifestUrl);
        if (!response.ok) throw new Error('Manifest not found');
        const manifest = await response.json();
        const nerveEntries = manifest.nerves || [];

        const gltfLoader = new GLTFLoader();
        gltfLoader.setDRACOLoader(dracoLoader);
        for (const n of nerveEntries) {
          const gltf = await gltfLoader.loadAsync('./models/nerves/' + n.file);
          const obj = gltf.scene;
          obj.visible = false;
          obj.userData = n;
          nerveGroup.add(obj);
          idToNerve.set(n.id, obj);
          console.log(`Loaded ${n.id}: ${n.name} (${n.source}, ${n.license})`);
        }

        console.log(`Loaded ${nerveEntries.length} cranial nerve models`);
        populateNerveUI(nerveEntries);
      }

      // Populate UI with cranial nerve checkboxes
      function populateNerveUI(nerveEntries) {
        const cranialNerves = [
          { id: 'CN_I', name: 'Olfactory' },
          { id: 'CN_II', name: 'Optic' },
          { id: 'CN_III', name: 'Oculomotor' },
          { id: 'CN_IV', name: 'Trochlear' },
          { id: 'CN_V', name: 'Trigeminal' },
          { id: 'CN_VI', name: 'Abducens' },
          { id: 'CN_VII', name: 'Facial' },
          { id: 'CN_VIII', name: 'Vestibulocochlear' },
          { id: 'CN_IX', name: 'Glossopharyngeal' },
          { id: 'CN_X', name: 'Vagus' },
          { id: 'CN_XI', name: 'Accessory' },
          { id: 'CN_XII', name: 'Hypoglossal' }
        ];

        cranialNerves.forEach(cn => {
          const nerveEntry = nerveEntries.find(n => n.id === cn.id);
          const isAvailable = !!nerveEntry;

          const item = document.createElement('div');
          item.className = 'nerve-item';

          const checkbox = document.createElement('input');
          checkbox.type = 'checkbox';
          checkbox.id = cn.id;
          checkbox.disabled = !isAvailable;
          if (isAvailable) {
            checkbox.addEventListener('change', (e) => {
              toggleNerve(cn.id, e.target.checked);
            });
          }

          const label = document.createElement('label');
          label.htmlFor = cn.id;
          label.textContent = `${cn.id}: ${cn.name}`;
          if (!isAvailable) {
            label.style.opacity = '0.5';
          }

          item.appendChild(checkbox);
          item.appendChild(label);
          nerveList.appendChild(item);
        });
      }

      // Nerve visibility controls
      function toggleNerve(id, visible) {
        const obj = idToNerve.get(id);
        if (obj) {
          obj.visible = visible;
          if (visible) {
            // Clear previous highlight
            if (lastToggledNerve) clearHighlight(lastToggledNerve);
            lastToggledNerve = obj;
            // Apply highlight to new active nerve
            applyHighlight(obj);
          } else if (obj === lastToggledNerve) {
            // If hiding the currently highlighted nerve, clear highlight
            clearHighlight(obj);
            lastToggledNerve = null;
          }
          // Update UI checkbox
          const checkbox = document.getElementById(id);
          if (checkbox) checkbox.checked = visible;
        }
      }

      // Highlight functions
      function applyHighlight(obj) {
        obj.traverse(child => {
          if (child.material) {
            if (Array.isArray(child.material)) {
              child.material.forEach(mat => {
                mat.emissive = new THREE.Color(0x444444);
              });
            } else {
              child.material.emissive = new THREE.Color(0x444444);
            }
          }
        });
      }

      function clearHighlight(obj) {
        obj.traverse(child => {
          if (child.material) {
            if (Array.isArray(child.material)) {
              child.material.forEach(mat => {
                mat.emissive = new THREE.Color(0x000000);
              });
            } else {
              child.material.emissive = new THREE.Color(0x000000);
            }
          }
        });
      }

      function showAllNerves() {
        idToNerve.forEach((obj, id) => {
          obj.visible = true;
          // Update UI checkbox
          const checkbox = document.getElementById(id);
          if (checkbox) checkbox.checked = true;
        });
        // Clear highlight when showing all
        if (lastToggledNerve) clearHighlight(lastToggledNerve);
        lastToggledNerve = null;
      }

      function hideAllNerves() {
        idToNerve.forEach((obj, id) => {
          obj.visible = false;
          // Update UI checkbox
          const checkbox = document.getElementById(id);
          if (checkbox) checkbox.checked = false;
        });
        // Clear highlight when hiding all
        if (lastToggledNerve) clearHighlight(lastToggledNerve);
        lastToggledNerve = null;
      }

      function soloNerve(obj) {
        if (obj) {
          hideAllNerves();
          obj.visible = true;
          // Update UI checkbox for soloed nerve
          const id = Array.from(idToNerve.entries()).find(([_, o]) => o === obj)?.[0];
          if (id) {
            const checkbox = document.getElementById(id);
            if (checkbox) checkbox.checked = true;
          }
        }
      }

      function frameNerve(obj) {
        if (obj) frameObject(camera, controls, obj, renderer);
      }

      // Load and frame the model
      loadModel(scene).then(object => {
        frameObject(camera, controls, object, renderer);
        // Load cranial nerves if manifest exists
        loadNerveModels(scene).catch(e => console.log('No nerve models loaded:', e.message));
      }).catch(e => console.error(e));

      // Frame object in view
      function frameObject(camera, controls, object, renderer) {
        const box = new THREE.Box3().setFromObject(object);
        const size = box.getSize(new THREE.Vector3()).length();
        const center = box.getCenter(new THREE.Vector3());
        controls.target.copy(center);
        camera.near = size / 100; camera.far = size * 10; camera.updateProjectionMatrix();
        const dist = size * 1.2; camera.position.copy(center).add(new THREE.Vector3(dist, dist*0.6, dist));
        renderer.render(object.parent, camera);
      }

      // Keyboard controls for nerves
      addEventListener('keydown', (event) => {
        const key = event.key.toLowerCase();
        // Number keys 1-9, 0 for nerves CN_I to CN_X
        if (key >= '1' && key <= '9') {
          const nerveIndex = parseInt(key) - 1;
          const nerveIds = ['CN_I', 'CN_II', 'CN_III', 'CN_IV', 'CN_V', 'CN_VI', 'CN_VII', 'CN_VIII', 'CN_IX'];
          if (nerveIds[nerveIndex]) {
            const obj = idToNerve.get(nerveIds[nerveIndex]);
            if (obj) toggleNerve(nerveIds[nerveIndex], !obj.visible);
          }
        } else if (key === '0') {
          const obj = idToNerve.get('CN_X');
          if (obj) toggleNerve('CN_X', !obj.visible);
        } else if (key === 'a') {
          showAllNerves();
        } else if (key === 'h') {
          hideAllNerves();
        } else if (key === 's') {
          soloNerve(lastToggledNerve);
        } else if (key === 'f') {
          frameNerve(lastToggledNerve);
        }
      });

      addEventListener('resize', () => { renderer.setSize(innerWidth, innerHeight); camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix(); });
      (function animate(){ requestAnimationFrame(animate); controls.update(); renderer.render(scene, camera); })();
    </script>
  </body>
</html>
