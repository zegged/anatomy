<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>POC â€“ Three.js + GLB</title>
    <style>html,body{margin:0;height:100%}canvas{display:block;width:100%;height:100%}</style>
    <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.157.0/build/three.module.js",
        "three/examples/jsm/": "https://unpkg.com/three@0.157.0/examples/jsm/"
      }
    }
    </script>
  </head>
  <body>
    <canvas id="c"></canvas>
    <script type="module">
      import * as THREE from 'three';
      import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
      import { OBJLoader } from 'three/examples/jsm/loaders/OBJLoader.js';
      import { MTLLoader } from 'three/examples/jsm/loaders/MTLLoader.js';
      import { STLLoader } from 'three/examples/jsm/loaders/STLLoader.js';
      import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';

      const canvas = document.querySelector('#c');
      const renderer = new THREE.WebGLRenderer({ antialias: true, canvas });
      renderer.setPixelRatio(devicePixelRatio);
      renderer.setSize(innerWidth, innerHeight);
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x202124);
      const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 100);
      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;

      scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 1.0));
      const dir = new THREE.DirectionalLight(0xffffff, 1.0); dir.position.set(5,10,7.5); scene.add(dir);

      const MODEL_ROOT = './models/anatomytool/';
      const GLB = MODEL_ROOT + 'model.glb';
      const GLTF = MODEL_ROOT + 'model.gltf';
      const OBJ = MODEL_ROOT + 'model.obj';
      const MTL = MODEL_ROOT + 'model.mtl';
      const STL = MODEL_ROOT + 'model.stl';

      async function exists(url){ const r = await fetch(url,{method:'HEAD'}); return r.ok; }

      async function loadModel(scene) {
        // Prefer GLB/GLTF for textures and performance
        if (await exists(GLB)) {
          const gltf = await new GLTFLoader().loadAsync(GLB);
          scene.add(gltf.scene);
          return gltf.scene;
        }
        if (await exists(GLTF)) {
          const gltf = await new GLTFLoader().loadAsync(GLTF);
          scene.add(gltf.scene);
          return gltf.scene;
        }
        // Fall back to OBJ+MTL for textures
        if (await exists(MTL) && await exists(OBJ)) {
          const mtl = await new MTLLoader().loadAsync(MTL);
          mtl.preload();
          const objLoader = new OBJLoader();
          objLoader.setMaterials(mtl);
          const obj = await objLoader.loadAsync(OBJ);
          scene.add(obj);
          return obj;
        }
        // Fall back to OBJ only
        if (await exists(OBJ)) {
          const obj = await new OBJLoader().loadAsync(OBJ);
          scene.add(obj);
          return obj;
        }
        // Final fallback to STL
        if (await exists(STL)) {
          const geom = await new STLLoader().loadAsync(STL);
          const mat = new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0.1, roughness: 0.8 });
          const mesh = new THREE.Mesh(geom, mat);
          scene.add(mesh);
          return mesh;
        }
        throw new Error('No supported model found under ' + MODEL_ROOT);
      }

      // Load cranial nerve models from manifest
      const nerveGroup = new THREE.Group();
      scene.add(nerveGroup);
      const idToNerve = new Map();
      let lastToggledNerve = null;

      async function loadNerveModels(scene) {
        const manifestUrl = './models/nerves/manifest.json';
        const response = await fetch(manifestUrl);
        if (!response.ok) throw new Error('Manifest not found');
        const nerveEntries = await response.json();

        const gltfLoader = new GLTFLoader();
        for (const n of nerveEntries) {
          const gltf = await gltfLoader.loadAsync(n.localPath);
          const obj = gltf.scene;
          obj.visible = false;
          obj.userData = n;
          nerveGroup.add(obj);
          idToNerve.set(n.id, obj);
          console.log(`Loaded ${n.id}: ${n.name} (${n.credit}, ${n.license})`);
        }

        console.log(`Loaded ${nerveEntries.length} cranial nerve models`);
      }

      // Nerve visibility controls
      function toggleNerve(id, visible) {
        const obj = idToNerve.get(id);
        if (obj) {
          obj.visible = visible;
          if (visible) lastToggledNerve = obj;
        }
      }

      function showAllNerves() {
        idToNerve.forEach(obj => obj.visible = true);
      }

      function hideAllNerves() {
        idToNerve.forEach(obj => obj.visible = false);
      }

      function soloNerve(obj) {
        if (obj) {
          hideAllNerves();
          obj.visible = true;
        }
      }

      function frameNerve(obj) {
        if (obj) frameObject(camera, controls, obj, renderer);
      }

      // Load and frame the model
      loadModel(scene).then(object => {
        frameObject(camera, controls, object, renderer);
        // Load cranial nerves if manifest exists
        loadNerveModels(scene).catch(e => console.log('No nerve models loaded:', e.message));
      }).catch(e => console.error(e));

      // Frame object in view
      function frameObject(camera, controls, object, renderer) {
        const box = new THREE.Box3().setFromObject(object);
        const size = box.getSize(new THREE.Vector3()).length();
        const center = box.getCenter(new THREE.Vector3());
        controls.target.copy(center);
        camera.near = size / 100; camera.far = size * 10; camera.updateProjectionMatrix();
        const dist = size * 1.2; camera.position.copy(center).add(new THREE.Vector3(dist, dist*0.6, dist));
        renderer.render(object.parent, camera);
      }

      // Keyboard controls for nerves
      addEventListener('keydown', (event) => {
        const key = event.key.toLowerCase();
        // Number keys 1-9, 0 for nerves CN_I to CN_X
        if (key >= '1' && key <= '9') {
          const nerveIndex = parseInt(key) - 1;
          const nerveIds = ['CN_I', 'CN_II', 'CN_III', 'CN_IV', 'CN_V', 'CN_VI', 'CN_VII', 'CN_VIII', 'CN_IX'];
          if (nerveIds[nerveIndex]) {
            const obj = idToNerve.get(nerveIds[nerveIndex]);
            if (obj) toggleNerve(nerveIds[nerveIndex], !obj.visible);
          }
        } else if (key === '0') {
          const obj = idToNerve.get('CN_X');
          if (obj) toggleNerve('CN_X', !obj.visible);
        } else if (key === 'a') {
          showAllNerves();
        } else if (key === 'h') {
          hideAllNerves();
        } else if (key === 's') {
          soloNerve(lastToggledNerve);
        } else if (key === 'f') {
          frameNerve(lastToggledNerve);
        }
      });

      addEventListener('resize', () => { renderer.setSize(innerWidth, innerHeight); camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix(); });
      (function animate(){ requestAnimationFrame(animate); controls.update(); renderer.render(scene, camera); })();
    </script>
  </body>
</html>
